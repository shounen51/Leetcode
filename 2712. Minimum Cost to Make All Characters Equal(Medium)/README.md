給一個由'0''1'組成之字串，計算將其變成全部相同字元('0'或'1')需要多少計算成本
對字串只能有兩個操作：
1. 將第i個以前的字全部反轉(0變1或1變0)
2. 將第i個以後的字全部反轉(0變1或1變0)
每反轉一個字視為 1 成本

範例：
intput = "0011"
選擇將第2位置以前的字反轉得到"1111"，總共反轉兩個字故成本為2

intput = "010101"
反轉3以前"101101" > 成本3
反轉2以前"011101" > 成本2
反轉1以前"111101" > 成本1
反轉5以後"111110" > 成本2
反轉6以後"111111" > 成本1
成本為 3+2+1+2+1=9

我的想法：
操作不是往前就是往後，所以一個字串單次操作的最大成本應為長度/2，而不應該往較長的那端反轉，以此概念發想將字串從中間一分為二，再把前字串反轉，前後兩端的字串分別就只剩第二種操作，可以一併處理
而應該反轉的目標("1"或"0")則由中間字串決定
長度為奇數的情況下目標為最中間的字
長度為偶數的情況則中間的兩個字皆有可能，觀察兩個關鍵字連續出現的次數來決定，比如說"100*01*100"
前字串反轉後得到"*0*001"，後字串為"*1*100"
前字串的*0*連續了3次而字串的*1*則只連續了兩次，表示*0*反轉起來成本比較小，所以目標為*0*
剩下的就是計算反轉的成本，在反轉的時候並不需要真的把字串都反轉，將目標反轉也是等效的



